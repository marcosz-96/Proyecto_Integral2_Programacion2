# DeliveryGo

**DeliveryGo** es un mini-ecommerce en consola desarrollado en C# puro, dise√±ado como una demostraci√≥n educativa de patrones de dise√±o de software. Implementa un sistema de checkout simple donde los usuarios pueden gestionar un carrito de compras, seleccionar m√©todos de env√≠o y pago, confirmar pedidos y recibir notificaciones de cambios de estado. El proyecto est√° dividido en etapas para simular el trabajo en equipo, enfoc√°ndose en patrones como Command, Strategy, Singleton, Factory, Adapter, Decorator, Builder, Observer y Facade.

Este proyecto es ideal para estudiantes o desarrolladores que quieran aprender sobre patrones de dise√±o en un contexto pr√°ctico, sin dependencias externas ni complejidades de UI web/m√≥vil.

## ¬øQu√© hace el programa?

DeliveryGo simula un flujo completo de compra en una aplicaci√≥n de delivery de productos electr√≥nicos y accesorios. El programa permite a los usuarios:

- **Gestionar un carrito de compras:** Agregar, quitar o modificar cantidades de √≠tems, con soporte para deshacer (Undo) y rehacer (Redo) acciones.
- **Calcular env√≠os din√°micos:** Elegir m√©todos de env√≠o (moto, correo o retiro en tienda) y aplicar reglas como env√≠o gratis por umbral de compra.
- **Procesar pagos:** Seleccionar m√©todos de pago (tarjeta, transferencia o Mercado Pago), aplicar impuestos (IVA) y descuentos (cupones).
- **Confirmar pedidos:** Construir pedidos paso a paso, simular cambios de estado (pendiente, pagado, enviado) y notificar a observadores (cliente, log√≠stica, auditor√≠a).
- **Interactuar v√≠a men√∫:** Una interfaz de consola intuitiva gu√≠a al usuario a trav√©s de todas las etapas del checkout.

Todo se ejecuta en una aplicaci√≥n de consola, mostrando resultados en tiempo real (subtotales, totales, notificaciones) para una experiencia interactiva.

## ¬øQu√© tecnolog√≠as usa?

- **Lenguaje principal:** C# (.NET 9).
- **Entorno de ejecuci√≥n:** Aplicaci√≥n de consola pura (sin frameworks web como ASP.NET).
- **Herramientas de desarrollo:** Visual Studio 2022.
- **Control de versiones:** Git y GitHub para colaboraci√≥n en equipo.
- **Otras dependencias:** Ninguna externa (sin NuGet packages, bases de datos o APIs reales; usa simulaciones para pagos y env√≠os).

El proyecto es liviano y portable, compilable con `dotnet build` y ejecutable con `dotnet run`.

## ¬øQu√© necesidad satisface?

DeliveryGo satisface la necesidad educativa de demostrar c√≥mo aplicar patrones de dise√±o en un sistema realista de e-commerce, sin la complejidad de un proyecto comercial completo. En un contexto de desarrollo de software:

- **Para estudiantes/desarrolladores:** Proporciona un ejemplo pr√°ctico y modular para aprender SOLID principles y patrones GoF (Gang of Four), facilitando la comprensi√≥n de c√≥mo desacoplar componentes para mantenerabilidad y extensibilidad.
- **Para equipos de desarrollo:** Muestra c√≥mo dividir un proyecto en etapas colaborativas, usando interfaces y fachadas para integrar subsistemas independientes.
- **Para prototipado r√°pido:** Ofrece una base para simular flujos de negocio (como checkouts) en entornos educativos o de prueba, evitando costos de infraestructura.

En resumen, resuelve la brecha entre teor√≠a de patrones y pr√°ctica, permitiendo experimentar con refactorizaciones y extensiones sin riesgos.

## ¬øEn qu√© rubros/actividades podr√≠a ser aplicado?

DeliveryGo puede adaptarse o extenderse en varios rubros y actividades:

- **Educaci√≥n y Formaci√≥n:** Como material did√°ctico en cursos de programaci√≥n orientada a objetos, dise√±o de software o ingenier√≠a de software. Ideal para talleres sobre patrones de dise√±o o metodolog√≠as √°giles.
- **Prototipado de E-commerce:** En startups o consultor√≠as para crear demos r√°pidas de sistemas de ventas online, delivery de comida/productos o marketplaces (ej. para m√°s adelante, agregar integraci√≥n con bases de datos reales).
- **Desarrollo de Software Educativo:** En rubros como fintech (simulaci√≥n de pagos), log√≠stica (optimizaci√≥n de env√≠os) o retail (gesti√≥n de inventarios), para entrenar equipos en patrones escalables.
- **Actividades de Colaboraci√≥n:** En hackathons, proyectos universitarios o equipos remotos, para practicar Git workflows, code reviews y divisi√≥n de tareas.
- **Extensiones Comerciales:** Podr√≠a evolucionar a una app web/m√≥vil para rubros como delivery de groceries, e-learning (cursos pagos) o servicios on-demand, integrando APIs reales como Stripe o UPS.

Su modularidad lo hace vers√°til para cualquier escenario donde se necesite un flujo transaccional simple y extensible.

## üöÄ C√≥mo usar la aplicaci√≥n

1. **Clonar o descargar el repositorio:**  
   Abre una terminal y ejecuta:  
  $ git clone git@github.com:Briancourel/Actividad-DeliveryGo.git

  
2. **Abrir el proyecto en Visual Studio**  
- Instala .NET SDK 9 desde [dotnet.microsoft.com](https://dotnet.microsoft.com/download).  
  - Abre la carpeta del proyecto en tu IDE.

3. **Compilar el proyecto:**  
En la terminal:  
O usa el bot√≥n de "Build" en tu IDE (Ctrl + Shift + B en Visual Studio).

4. **Ejecutar en consola (o ejecutar el debug del IDE):**  
5. O presiona F5 en el IDE para modo debug.

5. **Seguir las opciones del men√∫:**  
Se abrir√° un men√∫ interactivo en consola. Usa n√∫meros para navegar:  
- Agrega √≠tems al carrito (opci√≥n 1).  
- Elige m√©todo de env√≠o (opci√≥n 7).  
- Paga y confirma el pedido (opciones 8 y 9).  
- Prueba Undo/Redo (opciones 5 y 6).  
- Sal con la opci√≥n 0.

El programa simula todo el flujo; no requiere conexi√≥n a internet ni datos reales.

## üë• Integrantes del equipo

- **Alumno A:
Nombre: Courel Brian - GitHub: (https://github.com/Briancourel)

- **Alumno B:
Nombre: Gomez Marco - GitHub: (https://github.com/marcosz-96)

## üë• Trabajos realizados

- **Alumno A (Etapa 1 - Carrito & Command)**
- Trabajo realizado: Implement√© la gesti√≥n del carrito con patr√≥n Command, incluyendo comandos para agregar/quitar/modificar √≠tems, soporte Undo/Redo y la clase EditorCarrito. Tambi√©n cre√© pruebas unitarias aisladas para esta etapa.

- **Alumno B (Etapa 2 - Env√≠o & Strategy + Singleton)**
- Trabajo realizado: Desarroll√© las estrategias de env√≠o (EnvioMoto, EnvioCorreo, RetiroEnTienda) y el Singleton ConfigManager para manejar umbrales de env√≠o gratis e IVA. Integr√© c√°lculos din√°micos en la Facade.

- **Alumno A (Etapa 3 - Pago + Pedido + Facade)**
- Trabajo realizado: Implement√© Factory para pagos, Adapter para Mercado Pago (SDK falsa), Decorators para IVA/cupones, Builder para Pedido, Observer para notificaciones y la CheckoutFacade para unir todo.

- **Alumno B: (Etapa 4 - UI y Refinamientos)**
- Trabajo realizado: Creaci√≥n del men√∫ interactivo en AppRunner, revisiones de c√≥digo, integraci√≥n final y documentaci√≥n. Usando Git para merges y PRs.

## üß© Patrones aplicados

El proyecto utiliza patrones de dise√±o GoF para hacer el c√≥digo modular, extensible y mantenible. Cada uno se aplica en funcionalidades espec√≠ficas:

- **Command:** En la gesti√≥n del carrito (Etapa 1). Permite encapsular acciones como agregar/quitar √≠tems o cambiar cantidades en objetos ejecutables, con historial para Undo/Redo. Ejemplo: `AgregarItemCommand` ejecuta `_carrito.Agregar(item)` y guarda el estado previo para revertir.

- **Strategy:** Para calcular costos de env√≠o (Etapa 2). Define un familia de algoritmos intercambiables (EnvioMoto, EnvioCorreo, RetiroEnTienda) que se seleccionan din√°micamente seg√∫n la elecci√≥n del usuario, evitando condicionales complejos.

- **Singleton:** En la configuraci√≥n global (Etapa 2). Asegura una √∫nica instancia de `ConfigManager` para valores como umbral de env√≠o gratis o IVA (21%), accesible desde cualquier parte sin duplicaci√≥n.

- **Factory:** En la creaci√≥n de pagos (Etapa 3). `PagoFactory` genera instancias de `IPago` seg√∫n el tipo (tarjeta, transferencia, MercadoPago), ocultando la l√≥gica de instanciaci√≥n.

- **Adapter:** Para integrar SDK externa de pago (Etapa 3). `PagoAdapterMp` adapta la interfaz de una "SDK falsa" de Mercado Pago a `IPago`, permitiendo compatibilidad sin cambiar c√≥digo cliente.

- **Decorator:** En modificadores de pagos (Etapa 3). Clases como `PagoConImpuesto` o `PagoConCupon` envuelven un pago base para agregar IVA o descuentos din√°micamente, sin alterar la clase original.

- **Builder:** Para construir pedidos complejos (Etapa 3). `PedidoBuilder` permite armar objetos `Pedido` paso a paso (agregar √≠tems, direcci√≥n, estado), ideal para objetos con muchos par√°metros opcionales.

- **Observer:** En notificaciones de pedidos (Etapa 3). `PedidoService` notifica a observadores (ClienteObserver, LogisticaObserver) de cambios de estado (ej. "Pagado" ‚Üí "Enviado"), implementando el patr√≥n Publish-Subscribe.

- **Facade:** Para integrar subsistemas (Etapa 3). `CheckoutFacade` simplifica el acceso a carrito, env√≠o, pago y pedido, ocultando complejidades internas y orquestando el flujo completo.

Estos patrones siguen principios SOLID, facilitando pruebas y extensiones.

## üìñ Caso narrado de uso

**Ejemplo: Compra de una Laptop y Accesorios con Env√≠o y Pago**

1. **Inicio y Agregar √çtem:** El usuario ejecuta `dotnet run` y ve el men√∫ principal. Selecciona opci√≥n 1 ("Agregar √≠tem al carrito"). Ingresa: SKU="LPT001", Nombre="Laptop Gaming", Precio=1200, Cantidad=1. El sistema confirma: "√çtem agregado. Subtotal: $1200.00".

2. **Agregar Otro √çtem y Error:** Selecciona opci√≥n 1 de nuevo: SKU="MOU002", Nombre="Mouse", Precio=25, Cantidad=3. Subtotal actualizado: $1275.00. El usuario se equivoca en la cantidad del mouse y selecciona opci√≥n 2 ("Cambiar cantidad"): Cambia a 1. Pero decide revertir: Opci√≥n 5 ("Undo") restaura la cantidad a 3.

3. **Ver Resumen y Elegir Env√≠o:** Selecciona opci√≥n 4 ("Ver subtotal y total"). Muestra: Subtotal $1275.00, Env√≠o (por defecto: $50), Total $1325.00. Luego, opci√≥n 7 ("Elegir m√©todo de env√≠o"): Elige "2 - Correo" (costo $80, pero gratis si subtotal > $500? No aplica aqu√≠). Actualiza total a $1355.00.

4. **Aplicar Descuento y Pagar:** Opci√≥n 8 ("Pagar pedido"). Elige "3 - Mercado Pago". El sistema aplica Decorator: IVA 21% ($284.55) y un cup√≥n de 10% (-$135.50). Total final: $1504.05. Simula procesamiento exitoso: "Pago aprobado".

5. **Confirmar Pedido y Notificaciones:** Opci√≥n 9 ("Confirmar pedido"). Ingresa direcci√≥n: "Calle Falsa 123". El Builder arma el Pedido. Cambia estado a "Pagado" ‚Üí Observer notifica: "Cliente: Su pedido #001 ha sido pagado." ‚Üí "Log√≠stica: Preparando env√≠o." El usuario ve el resumen final y puede salir (opci√≥n 0).

Este flujo demuestra la integraci√≥n de patrones: Command para Undo, Strategy para env√≠o, Decorator para pagos y Observer para notificaciones. ¬°Prueba variaciones para ver errores manejados!

## üîÆ Retos futuros

Para una versi√≥n 2.0 de DeliveryGo, consideramos agregar funciones vitales que escalen el proyecto:

- **Persistencia de Datos:** Integrar Entity Framework con SQLite para guardar carritos, pedidos e historial de usuarios, permitiendo sesiones persistentes.
- **Autenticaci√≥n de Usuarios:** Agregar login/register con JWT simple, para perfiles personalizados (historial de compras, direcciones guardadas).
- **Integraci√≥n Real de APIs:** Reemplazar simulaciones con APIs como Stripe para pagos, Google Maps para distancias de env√≠o o Twilio para notificaciones SMS.
- **UI Avanzada:** Migrar a una app Blazor WebAssembly para una interfaz web responsive, manteniendo los patrones backend.
- **An√°lisis y Reportes:** Usar Strategy para generar reportes (ventas diarias, m√©tricas de env√≠o) y Observer para alertas en tiempo real (ej. stock bajo).
- **Testing Automatizado:** Agregar xUnit para pruebas unitarias/integraci√≥n, cubriendo >80% del c√≥digo, y CI/CD con GitHub Actions.

Estos retos har√≠an de DeliveryGo una base para un e-commerce real, enfoc√°ndonos en escalabilidad y seguridad.

## üìå Notas finales

**Resumen del Trabajo Realizado:** DeliveryGo fue desarrollado en 4 etapas colaborativas, cubriendo desde la gesti√≥n b√°sica del carrito hasta un flujo completo de checkout. Aprendimos a aplicar patrones de dise√±o para resolver problemas reales como Undo/Redo, c√°lculos din√°micos y notificaciones, manteniendo el c√≥digo limpio y testable. El proyecto totaliza 100% cobertura de interfaces y cero dependencias externas.

**Informaci√≥n Extra:** 
- El IVA y umbrales son configurables v√≠a Singleton; modif√≠calos en `ConfigManager` para pruebas.
- Para depuraci√≥n, activa logs en `PedidoService` imprimiendo estados en consola.
- Si encuentras bugs, abre un issue en GitHub. 
- 
- ¬°Gracias por explorar DeliveryGo ‚Äì un gran ejercicio en patrones de dise√±o! üöÄ
